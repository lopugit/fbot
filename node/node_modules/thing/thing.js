var mongoose = require('mongoose')
dbconf = require('secrets')
dbconf = dbconf.mongodb
let uri = "mongodb://" + (dbconf.auth ? dbconf.username + ":" + dbconf.password + "@" : '') + dbconf.server + ":" + dbconf.port + "/" + dbconf.db + (dbconf.auth ? "?authSource=admin" : '')
let options = { useMongoClient: true }
let node = mongoose.createConnection(uri, options)
Schema = mongoose.Schema
moment = require('moment')

var thingSchema = new Schema({

    // origin Id to relate states when new states are created
    trueId: { type: Schema.ObjectId, ref: 'thing' },
    hash: { type: String },
    // organzational properties
    title: { type: String },
    names: { type: [String] },
    realms: { type: [String], default: ["all", "things"] },

    // values
    text: { type: String },
    number: { type: Number },
    url: { type: String },
    json: { type: {} },
    list: { type: [] },
    boolean: { type: Boolean },
    binary: { 
        data: { type: Buffer },
        // binary type .PNG .JPG for decoding if
        extension: { type: String }
    },

    // family relations | inventory of other things | child things
    things: { type: [{ type: Schema.ObjectId, ref: 'thing' }], default: [] },
    parents: { type: [{ type: Schema.ObjectId, ref: 'thing' }], default: [] },
    
    // ownership / privacy / access control / billing
    owner: { type: Schema.ObjectId, ref: 'entity' },
    owners: { type: [{ type: Schema.ObjectId, ref: 'entity' }] },
    payees: { type: [{ type: Schema.ObjectId, ref: 'entity' }] },
    
    // smart contract variable/dynamic pricing
    contract: {
        type: [{
            type: { type: String, required: true },
            thing: { type: Schema.ObjectId, ref: 'entity', required: true },
            amount: { type: Number, required: true, default: 1 },
            multiplier: { type: Number, required: true, default: 1 },
            unit: { type: String, required: true }
        }]
    },

    // meta data
    created: { type: Date, default: Date.now() },
    inception: { type: Date, default: Date.now() },
    age: { type: Number, default: 0 },
    lifetime: { type: Number, default: 0, min: 0, max: Infinity },
    location: { type: String },
    type: { type: String, enum: [
        String,
        Object,
        Number,
        Array,
        ]
    },

    // extendable schema
    properties: { type: [{ type: Schema.ObjectId, ref: 'thing' }], default: [] },
},{
    usePushEach: true
})

var thingModel = node.model('thing', thingSchema)

module.exports = thingModel

function createExampleThings() {
    let things = [
        "knife",
        "spoon",
        "fork",
        "plate",
        "dehydrator",
        "tissues",
        "cereal",
        "milk",
        "chocolate",
        "plant",
        "chainsaw",
        "garden shears",
        "rake",
        "lawn mower",
        "high pressure hose",
        "paint brush",
        "water bottle",
        "mobile phone",
        "laptop",
        "computer",
        "flashlight",
        "car",
        "house",
        "bed",
        "room",
        "stove",
        "land",
        "tomato",
        "zuchini",
        "potato",
        "cauliflower"
    ]
    thingModel.remove({}, err => {
        if (err) {
            console.log(err)
        } else {
            var loop = 1
            for (let l = 0; l < loop; l++) {
                for (let obj of things) {
                    let newObj = new thingModel({
                        thing: obj,
                        names: [obj],
                        type: 'object'
                    })
                    newObj.save(err => {
                        if (err) {
                            console.error("there was an error saving")
                            console.error(err)
                        }
                    })
                }
            }
        }
    })
}

let owl = require('owl')
let something = new thingModel({title: 'original thing'})
let someOtherThing = new thingModel({title: 'ayooo'})
something.things.push(someOtherThing)
let woowoo = JSON.parse(JSON.stringify(something))

let pointer = something.things[0]
console.log(pointer)
pointer = {}
console.log(pointer)
console.log(something.things[0])

// console.log(something)
// console.log(woowoo)
// something.title = 'edited'
// something.save()
//     .then((thing, err)=>{
//         console.error(err)
//         console.log(thing)
//         thingModel.findOneAndUpdate({_id: something._id}, woowoo, {new: true})
//             .then(thing=>{
//                 console.log(thing)
//                 thingModel.findOne({_id: something.things[0]})
//                     .then(thing=>{
//                         console.log(thing)
//                     })
//             })
//     })
// something.title = 'lol'
// // console.log(something)
// // console.log(somethingElse)
// something.save((thing, err)=>{
//     // console.log(err)
//     thingModel.findOne({_id: something._id})
//         .then((wat, err)=>{
//             console.log(wat)
//             console.log(somethingElse)
//             thingModel.findOneAndUpdate({_id: wat._id}, somethingElse, {upsert: true, new: true})
//                 .then((thing, err)=>{
//                     console.log(thing)
//                 })
//             // somethingElse._id = something._id
//             // console.log(somethingElse)
//             // somethingElse.save((thing, err)=>{
//             //     console.log(err)
//             //     console.log(thing)
//             //     thingModel.find({_id: somethingElse._id})
//             //         .then((otherThing, err)=>{
//             //             console.log(otherThing)
//             //         })
//             // })
//         })
// })
// thingModel.findOne({
//     _id: newThing._id
//   })
//   .then(thing=>{
//       console.log(thing)
//   })

function jsonConcat(o1, o2, sReturn) {
    for (let key in o2) {
    if (o2.hasOwnProperty(key)) {
        console.log(key)
        // o1[key] = {}
        o1[key] = o2[key]
      }
    }
    if (sReturn) {
      return o1
    }
  }